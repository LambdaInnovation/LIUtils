# Ripple语言规范
## ver: 0.1

综述
---

Ripple是一个非常轻量级的脚本语言。它的开发和维护由Lambda Innovation进行。它的创建初衷是用来进行轻量级的数值计算，把数值计算的逻辑和具体行为解耦。Ripple是一门嵌入式语言，它需要通过别的语言访问它的函数和值，而不是单独发挥效用。

Ripple现在在[AcademyCraft](https://github.com/LambdaInnovation/AcademyCraft)的技能操作部分和其他数值相关部分得到了广泛的应用。

本文档介绍的是Ripple本身的语言规范。要参考它在其他语言中的交互细节，请参考以下文档：

[Ripple的java实现](ripple_javaimpl.md)


语言规范
---

一个完整的Ripple脚本由以下部分所构成：

## 名称 (name)
名称不能单独存在。它在特定的地方指代不同的含义：变量名、函数名、命名空间的名称等。

一个名称可以被```[a-zA-Z_\-][a-zA-Z0-9_\-]*```这个正则表达式匹配。也就是说，它的第一个字母必须是英文字符、`_`、`-`中的任意一个，后续的字符必须是英文字符、`_`、`-`以及`0-9`中的任意一个。

## 注释 (comment)
通过`#`字符来开始一行注释。每行中，`#`字符之后的所有字符会被编译器忽略。

例子：
```
ns {
	niconiconi { 233 } # This is a comment that will be ignored!!
}
```

## 命名空间 (namespace)
语法：
``` name { element-list } ```

在命名空间里存放了函数、（嵌套的）命名空间、值。element-list是以上三种元素的任意排列。

在一些场合，命名空间也可以由[命名空间全称][alias]一节的方法进行表达。

例子：
```
ns {
	val { 5 }
	function(arg) { arg + 1 }
	ns2 { ... }
}
```

## 函数 (function)
语法：
``` name(arg1, arg2, ...) { expression } ```

一个函数由参数列表和一个作为返回值的表达式所构成。你无法在函数中声明中间变量和执行控制流。
每一个参数都只是一个名称，你无须指定传入的类型。每一个参数传入的值都只可能是整形或者浮点数两种。
你可以在作为返回值的表达式中通过参数名字获取参数的值。

调用一个函数以后，调用端会获取一个该函数表达式的值。

以下是一些函数的例子：
```
test {
	add(a, b) { a + b } #返回a+b
	mul2(a) { a * 2 } #返回a*2
}

```

## 表达式

一个表达式可以是以下几种类型之一：

* 数值字面值：233、1234、1.0、2.333333等。暂时不支持科学计数法。
* 括号：``(任意表达式)``，用来调整运算的优先级。
* 名称：某一个在当前作用域下可见的名字。在运行时被替换成该参数所对应的值。值的搜索规则请参考[名称查找]一节。
* 函数调用：``name(expr1, expr2, ...)`` 函数的搜索规则请参考[名称查找][namelook]一节。
* 二元运算：``表达式 op 表达式``，op可以是 + - / * 中的一个。二元运算的求值遵循通常的优先级和结合性规则。
* switch表达式：见[switch表达式][switchblock]一节。

每一个表达式都会在运行时最终计算为一个数值量。

例子：接上例，调用mul2(2)会得到4，调用add(3, 5)得到8.

## __switch__表达式
语法：
```
switch(name) {
	switchcase: expression;
	switchcase: expression;
	...
}
```
其中，__switchcase__是一个匹配标签。执行__switch__表达式时，会从上往下求值每一个标签。当匹配标签通过时，执行该匹配标签所对应的表达式。每个匹配语句之间用`;`分割。最后一个匹配语句无须书写`;`。

总共有三种可用的匹配标签：

* 数值字面值：当name的值等于数值字面值时，通过匹配。
* __when__ boolean_expression：当布尔表达式（后述）为真时，通过匹配。
* __default__：当没有任何标签被匹配时，通过匹配。

以下是switch进行字面值匹配的例子：
```
switch(name) {
case 0: 100;
case 1: 200;
case 2: 300;
default: -1
}
```

如果没有成功匹配到标签，调用端会抛出一个异常。

## 布尔表达式(boolean expression)
布尔表达式只出现在逻辑运算当中（目前来说，只有__switch__的__when__匹配标签）。你无法把布尔值传入函数或者干其他的事。
布尔表达式通过表达式之间的比较构造。可用的比较运算符有：``==、!=、>=、>、<=、<。``

以下是一些布尔表达式的例子：
```
3 > 5 //比较字面值
4 == arg //比较字面值和参数
4 == arg + 5 //比较字面值和表达式
```

以下是switch和布尔表达式的综合应用的例子：
```
damage(exp, entity_distance) {
	(3 + exp * 5) *
	switch(entity_distance) {
		when <=5: 2;
		default: 1;
	}
}
```

## 值(value)
语法：
```
name { constant_value }
```

值用来存储字面值。可以是一个整数或者浮点数。

例子：
```
guiData {
x { 128 } y { 233 }
width { 50 } height { 50 }
}
```

## 命名空间全称
以下名字
``ns1.ns2.name``
在特定场合下是有效的。

如果它出现在一个元素（函数/值/命名空间）的声明里，那么它等价于下面的声明：
```
ns1 {
	ns2 {
		name { ... }
	}
}
```

如果它出现在一个函数调用的位置，则会按照在[名称查找][namelook]一节的说明进行搜索。

事实上，``ns1.ns2``通用的作为上述``ns2``命名空间的全称。该全程会在名字查找时用到。

## 名称查找
当在一个函数中进行名字求值或者函数调用时，名字查找便会发生。名字查找的规则如下：

- （在查找值时）如果该值是一个参数名，将其展开为参数名的值并结束名字查找。
- 将该名字串接到该函数所属的命名空间内，以得到的名称搜索该名字。如果找到，对其求值并结束名字查找。
- 如果没有找到，直接以该名字作为全称搜索该名字。如果找到，对其求值并结束名字查找。
- 如果以上三步搜索都失败，则求值失败，抛出一个异常。

名字的查找是运行时发生的。它与声明的顺序无关。事实上，你可以书写多个脚本，然后把它们合并起来一起使用。

例子：
```
val { 5 }
ns {
	fun(x) { x - 5 }
	func0(x) { fun(x) * 2 } # 正确：调用ns.fun
	ns2 {
		func(x) { val + x } # 正确：val是全局的val
		func2(x) { fun(x) + 1 } # 错误：'fun'不在同级作用域也不在全局命名空间中
	}
}
```


## 标准库
Ripple实现了一系列和数值计算密切相关的标准库函数。它们都定义在全局命名空间中。

* sqrt(x): 计算x的平方根。
* exp(x): 计算e^x的值。
* lerp(a, b, lambda): 对a和b进行线性插值计算。等价于a * (1 - lambda) + b * lambda。
* pow(x, e)：计算x^e的值。
* sin(x)：计算sin(x)的值。
* cos(x)：计算cos(x)的值。
* max(a, b)：计算a和b之间的最大值。
* min(a, b)：计算a和b之间的最小值。
* range_double(a, b)：获取一个在[a, b)之间的随机浮点数。
* range_int(a, b):获取一个在[a, b)之间的随机整数。
* floor(x)：计算一个浮点数的向下取整值。

[alias]: #命名空间全称
[namelook]: #名称查找
[switchblock]: #switch表达式
